---
chapter: 4
title: Ollie's Corner
description: This is all about Ollie
date:   2016-02-08 10:55:39 -0800
layout: cosmos-show
categories: cosmos
length: 1 - 2 hours
permalink: /cosmos/4-ollie
image: poster.png
order: 4
tags: [ollie, corner, tutorial, getting started, basics, introduction, easy, c4]
---

# Checkmark Animation

In this tutorial I'll show you how to create the following check mark animation using C4. 
[insert checkmark animation]

After a brainstorm session with Jake and Travis, we determined that in order to accomplish this animation we would need three shapes. 
[insert 3 shapes pictures]

The shapes were designed in Illustrator and then translated to paths using PaintCode. With the paths in Xcode it was just a matter of timing the animations.

##Shaping our Paths

####Download C4 Installer
You'll need to download C4 in order to complete this tutorial. You can find the installer [here]add c4installer link.

####Create Bezier 1
Open up Xcode and start a new C4 project. In your project's <code>WorkSpace</code>, start by creating a class variable to use as your first shape. In <code>setup()</code>, change the <code>canvas.backgroundColor</code> to <code>C4Purple</code>, initialize your shape and add it to the canvas :


    class WorkSpace: C4CanvasController {
        var b1: C4Shape!
    
        override func setup() {
            canvas.backgroundColor = C4Purple
    
            b1 = createBezier1()

            canvas.add(b1)
        }
    
        func createBezier1() -> C4Shape {
            let bezier = UIBezierPath()
            bezier.moveToPoint(CGPointMake(177.2, 30.4))
            bezier.addCurveToPoint(CGPointMake(103.8, 0), controlPoint1: CGPointMake(158.4, 11.6), controlPoint2: CGPointMake(132.5, 0))
            bezier.addCurveToPoint(CGPointMake(0, 103.8), controlPoint1: CGPointMake(46.5, 0), controlPoint2: CGPointMake(0, 46.5))
            bezier.addCurveToPoint(CGPointMake(103.8, 207.6), controlPoint1: CGPointMake(0, 161.1), controlPoint2: CGPointMake(46.5, 207.6))
            bezier.addCurveToPoint(CGPointMake(207.6, 103.8), controlPoint1: CGPointMake(161.1, 207.6), controlPoint2: CGPointMake(207.6, 161.1))
            bezier.addCurveToPoint(CGPointMake(177.2, 30.4), controlPoint1: CGPointMake(207.6, 75.1), controlPoint2: CGPointMake(196, 49.2))
            bezier.addLineToPoint(CGPointMake(69.2, 138.4))
    
            let path = C4Path(path: bezier.CGPath)
            let shape = C4Shape(path)
            return shape
        }
    }
>In the code above, the bezier.moveToPoint, bezier.addLineToPoint, bezier.addCurveToPoint etc. is generated from PaintCode. I just put this in a function and initialized a shape from it.



>PaintCode exports UIBezierPaths. To change the <code>UIBezierPath</code> into a <code>C4Shape</code>, I initialized a <code>C4Path</code> with the <code>bezier.CGPath</code> and initialized a <code>C4Shape</code> from this path.

 Now you can manipulate all the properties of <code>C4Shape</code> to achieve your desired animation.

####Create Bezier 2 and 3

Add two more <code>C4Shape</code> class variables and their createBezier functions. Below your <code>b1</code> class variable add:

    var b2: C4Shape!
    var b3: C4Shape!
    
Then in the body of your class add:

    func createBezier2() -> C4Shape {
        let bezier = UIBezierPath()
        bezier.moveToPoint(CGPointMake(90.9, 138.4))
        bezier.addLineToPoint(CGPointMake(10.6, 58.1))
        bezier.addCurveToPoint(CGPointMake(0, 103.8), controlPoint1: CGPointMake(3.8, 71.9), controlPoint2: CGPointMake(0, 87.4))
        bezier.addCurveToPoint(CGPointMake(103.8, 207.6), controlPoint1: CGPointMake(0, 161.1), controlPoint2: CGPointMake(46.5, 207.6))
        bezier.addCurveToPoint(CGPointMake(207.7, 103.8), controlPoint1: CGPointMake(161.1, 207.6), controlPoint2: CGPointMake(207.7, 161.1))
        bezier.addCurveToPoint(CGPointMake(103.9, 0), controlPoint1: CGPointMake(207.7, 46.5), controlPoint2: CGPointMake(161.3, 0))
        bezier.addCurveToPoint(CGPointMake(10.7, 58.1), controlPoint1: CGPointMake(63, 0), controlPoint2: CGPointMake(27.6, 23.7))

        let path = C4Path(path: bezier.CGPath)
        let shape = C4Shape(path)
        return shape
    }

    func createBezier3() -> C4Shape {
        let bezier = UIBezierPath()
        bezier.moveToPoint(CGPointMake(138.4, 138.4))
        bezier.addLineToPoint(CGPointMake(30.4, 30.4))
        bezier.addCurveToPoint(CGPointMake(0, 103.8), controlPoint1: CGPointMake(11.6, 49.2), controlPoint2: CGPointMake(0, 75.1))
        bezier.addCurveToPoint(CGPointMake(42, 187.2), controlPoint1: CGPointMake(0, 138), controlPoint2: CGPointMake(16.5, 168.3))
        bezier.addLineToPoint(CGPointMake(160, 69.2))

        let path = C4Path(path: bezier.CGPath)
        let shape = C4Shape(path)
        return shape
    }


####Setup the shapes
Finally, change your <code>setup()</code> function to look like this:

    override func setup() {
        canvas.backgroundColor = C4Purple

        b1 = createBezier1()
        b2 = createBezier2()
        b3 = createBezier3()

        b1.center = canvas.center
        b1.add(b2)
        b1.add(b3)
        canvas.add(b1)
    }

Create your new shapes the same way as your first. Then add them to that shape. Try running the app now and you should see something that looks like this:

[insert picture of just shapes no configuration]

##Animations
To get the effect we're looking for in this animation your shapes' <code>strokeColor</code>, <code>strokeStart</code> and <code>strokeEnd</code> properties need to be manipulated in a <code>C4ViewAnimation</code>. Here's how to change the color:
####animate()
Start by adding these class variables:

    var x = false
    let d = 0.5
    let dc = 0.25

The boolean named <code>x</code> will be used to track if your shapes are in their X state or not. The other two variables are constant values that will be used for timing your animations.

Add the following function to the body of your class:
    
    func animate(color: C4Color) {
        C4ViewAnimation(duration: d + dc) {
            self.b1.strokeColor = color
            self.b2.strokeColor = color
            self.b3.strokeColor = color
        }.animate()
    }
    
This function takes a <code>C4Color</code> as a parameter and animates your shapes' <code>strokeColor</code> to this parameter. The next step will go over how this function is called.

In <code>setup()</code> add a tap gesture to your canvas so you can start interacting with your app.

    canvas.addTapGestureRecognizer { location, state in
        if self.x {
            self.animate(C4Blue)
        } else {
            self.animate(C4Pink)
        }
        self.x = !self.x
    }

This tap gesture will check to see if your boolean <code>x</code> is true or false and change the color of your shapes accordingly. <code>self.x = !self.x</code> will change <code>x</code> to whatever it is not. So, if <code>x</code> is true <code>x</code> is now false.

####Create B1 Animations
Add these class variables to your project:
    
    var b1ToX: C4ViewAnimation!
    var b1ToCheck: C4ViewAnimation!

Moving from "check" state to "X" state and vice-versa requires animations. Your next step is to add this function to the body of your class:

    func createB1Animations() {
        b1ToX = C4ViewAnimation(duration: d) {
            self.b1.strokeStart = 0.6
        }
        b1ToX.curve = .EaseIn

        b1ToX.addCompletionObserver { () -> Void in
            let a = C4ViewAnimation(duration: self.dc) {
                self.b1.strokeStart = 0.88
                self.b1.strokeEnd = 1.0
            }
            a.curve = .EaseOut
            a.animate()
        }

        b1ToCheck = C4ViewAnimation(duration: d) {
            self.b1.strokeStart = 0.6
            self.b1.strokeEnd = 0.81
        }
        b1ToCheck.curve = .EaseIn
        b1ToCheck.addCompletionObserver { () -> Void in
            let a = C4ViewAnimation(duration: self.dc) {
                self.b1.strokeStart = 0.0
            }
            a.curve = .EaseOut
            a.animate()
        }

    }
    
 In this function, you're initializing your animations and setting their curve. You add a completion observer to your animations so that upon that animation completing, another animation will be triggered. 

####Create B2 and B3 Animations

The steps for creating the animations for your other shapes are the same as the steps for your first shape. This next bit should look familiar.

Add these class variables:

    var b2ToX: C4ViewAnimation!
    var b2ToCheck: C4ViewAnimation!

    var b3ToX: C4ViewAnimation!
    var b3ToCheck: C4ViewAnimation!
    
Create these functions that will initialize our animations when called:

    func createB2Animations() {
        b2ToX = C4ViewAnimation(duration: d) {
            self.b2.strokeStart = 0.15
            self.b2.strokeEnd = 0.21
        }
        b2ToX.curve = .EaseIn
        b2ToX.addCompletionObserver { () -> Void in
            let a = C4ViewAnimation(duration: self.dc) {
                self.b2.strokeEnd = 1.0
            }
            a.curve = .EaseOut
            a.animate()
        }

        b2ToCheck = C4ViewAnimation(duration: d) {
            self.b2.strokeEnd = 0.21
        }
        b2ToCheck.curve = .EaseIn
        b2ToCheck.addCompletionObserver { () -> Void in
            let a = C4ViewAnimation(duration: self.dc) {
                self.b2.strokeStart = 0.0
                self.b2.strokeEnd = 0.06
            }
            a.curve = .EaseOut
            a.animate()
        }
    }

    func createB3Animations() {
        b3ToX = C4ViewAnimation(duration: d) {
            self.b3.strokeStart = 0.0
            self.b3.strokeEnd = 0.19
        }

        b3ToCheck = C4ViewAnimation(duration: d) {
            self.b3.strokeStart = 0.804
            self.b3.strokeEnd = 1.0
        }
    }

>I experimented with different <code>strokeStart</code> and <code>strokeEnd</code> values before settling on the one's used in this tutorial.

The last thing to do for this step is to call all of your create animations functions in <code>setup()</code>. Above your tap gesture add:

    createB1Animations()
    createB2Animations()
    createB3Animations()


##Putting it all together
To make things a little more organized, create a function to handle everything that happens when the state changes to "X" and a function for when it changes to "Check".

####toX() and toCheck()

    func toX() {
        b1ToX.animate()
        delay(0.15) {
            self.b3ToX.animate()
        }
        delay(0.3) {
            self.b2ToX.animate()
        }
    }

    func toCheck() {
        b2ToCheck.animate()
        delay(0.5) {
            self.b3ToCheck.animate()
            self.b1ToCheck.animate()
        }
    }
When these functions are called, they will make the animations you created earlier animate.

####The tap gesture

Change the tap gesture to the following:

    canvas.addTapGestureRecognizer { location, state in
        if self.x {
            self.toCheck()
            self.animate(C4Blue)
        } else {
            self.toX()
            self.animate(C4Pink)
        }
        self.x = !self.x
    }

The logic of the gesture is the same as before, but now your <code>toCheck()</code> and <code>toX()</code> functions will be called at the appropriate times.

####Fin
Run your app now and tap to see the great animation you just created. I encourage you to try new shapes and values in the animations to see what cool effects you can come up with!

//insert gif of animation

